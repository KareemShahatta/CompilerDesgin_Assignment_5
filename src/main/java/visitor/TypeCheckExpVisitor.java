package visitor;import syntaxtree.*;import symboltable.*;public class TypeCheckExpVisitor extends TypeDepthFirstVisitor {    private Table symbolTable;    TypeCheckExpVisitor(Table symbolTable) {        this.symbolTable = symbolTable;    }        // Exp e1,e2;    public Type visit(And n) {        if (!(n.e1.accept(this) instanceof BooleanType)) {            symbolTable.error.complain("Left side of And must be of type boolean");        }        if (!(n.e2.accept(this) instanceof BooleanType)) {            symbolTable.error.complain("Right side of And must be of type boolean");        }        return new BooleanType();    }            // Exp e1,e2;    public Type visit(Or n) {        if (!(n.e1.accept(this) instanceof BooleanType)) {            symbolTable.error.complain("Left side of Or must be of type boolean");        }        if (!(n.e2.accept(this) instanceof BooleanType)) {            symbolTable.error.complain("Right side of Or must be of type boolean");        }        return new BooleanType();    }    // Exp e1,e2;    public Type visit(LessThan n) {        if (!(n.e1.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Left side of LessThan must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Right side of LessThan must be of type integer");        }        return new BooleanType();    }          // Exp e1,e2;    public Type visit(Equals n) {        Type left = n.e1.accept(this);        Type right = n.e2.accept(this);                if (left instanceof IntegerType && !(right instanceof IntegerType)) {            symbolTable.error.complain("Left side of Equals is type integer and Right side is not of type integer");        }        if (left instanceof BooleanType && !(right instanceof BooleanType)) {            symbolTable.error.complain("Left side of Equals is type boolean and Right side is not of type boolean");        }        return new BooleanType();    }        // Exp e1,e2;    public Type visit(Plus n) {        if (!(n.e1.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Left side of Plus must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Right side of Plus must be of type integer");        }        return new IntegerType();    }        // Exp e1,e2;    public Type visit(Minus n) {        if (!(n.e1.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Left side of Minus must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Right side of Minus must be of type integer");        }        return new IntegerType();    }    // Exp e1,e2;    public Type visit(Times n) {        if (!(n.e1.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Left side of Times must be of type integer");        }        if (!(n.e2.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Right side of Times must be of type integer");        }        return new IntegerType();    }    // Exp e1,e2;    public Type visit(ArrayLookup n) {        if (!(n.e1.accept(this) instanceof IntArrayType)) {            symbolTable.error.complain("Expression must be of type IntArray");        }        if (!(n.e2.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Right side of ArrayLookup must be of type integer");        }        return new IntegerType();    }    // Exp e;    public Type visit(ArrayLength n) {        if (!(n.e.accept(this) instanceof IntArrayType)) {            symbolTable.error.complain("Expression must be of type IntArray");        }        return new IntegerType();    }    // Exp e;    // Identifier i;    // ExpList el;    public Type visit(Call n) {        if (!(n.e.accept(this) instanceof IdentifierType)) {            symbolTable.error.complain("method " + n.i.toString()                    + " called  on something that is not a"                    + " class or Object.");            return null;        }        String mname = n.i.toString();        String cname = ((IdentifierType) n.e.accept(this)).s;        RamMethod calledMethod = TypeCheckVisitor.symbolTable.getMethod(mname, cname);        if (calledMethod == null)            return null;        for (int i = 0; i < n.el.size(); i++) {            Type t1 = null;            Type t2 = null;            if (calledMethod.getParamAt(i) != null) {                t1 = calledMethod.getParamAt(i).type();            }            t2 = n.el.elementAt(i).accept(this);            if (!TypeCheckVisitor.symbolTable.compareTypes(t1, t2)) {                symbolTable.error.complain("Type Error in arguments passed to "                        + cname + "." + mname);            }        }                if (calledMethod == null)            return null;        if (n.el.size() != calledMethod.numParams()) {            symbolTable.error.complain("Wrong number of arguments passed to "                    + cname + "." + mname);        }        return TypeCheckVisitor.symbolTable.getMethodType(mname, cname);    }    // int i;    public Type visit(IntegerLiteral n) {        return new IntegerType();    }    public Type visit(True n) {        return new BooleanType();    }    public Type visit(False n) {        return new BooleanType();    }        // String s;    public Type visit(Identifier n) {        return TypeCheckVisitor.symbolTable.getVarType(TypeCheckVisitor.currMethod,                TypeCheckVisitor.currClass, n.s);    }        // String s;    public Type visit(IdentifierExp n) {        return TypeCheckVisitor.symbolTable.getVarType(TypeCheckVisitor.currMethod,                TypeCheckVisitor.currClass, n.s);    }    public Type visit(This n) {        return TypeCheckVisitor.currClass.type();    }    // Exp e;    public Type visit(NewArray n) {        if (!(n.e.accept(this) instanceof IntegerType)) {            symbolTable.error.complain("Size of new array must be of type integer");        }        return new IntArrayType();    }    // Identifier i;    public Type visit(NewObject n) {        return new IdentifierType(n.i.s);    }    // Exp e;    public Type visit(Not n) {        if (!(n.e.accept(this) instanceof BooleanType)) {            symbolTable.error.complain("Expression must be of type boolean");        }        return new BooleanType();    }}//TypeCheckVisitor.